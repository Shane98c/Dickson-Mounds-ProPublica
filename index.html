<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Dickson Mounds</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/scrollama@3.2.0/build/scrollama.min.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        top: 0;
        height: 100vh;
        width: 100vw;
        max-width: 100%;
        position: sticky;
      }

      #features {
        pointer-events: none;
        padding-bottom: 10vh;
        transform: translate3d(0, 0, 0);
      }
      #features:last-of-type {
        padding-bottom: 100vh;
      }
      .hidden {
        visibility: hidden;
      }
      .centered {
        width: 90vw;
        max-width: 550px;
        margin: 0 auto;
      }
      .lefty {
        width: 33vw;
        max-width: 550px;
        margin-left: 5vw;
      }
      .step {
        z-index: 100;
        padding-bottom: 10vh;
        opacity: 0.95;
      }
      .step div {
        pointer-events: auto;
        padding: 15px 25px;
        line-height: 1.5rem;
        font-size: 1.1rem;
        font-family: "Tiempos Text", serif;
        box-shadow: 2px 3px 10px rgb(0 0 0 / 50%);
        color: #c3bfb5;
        background-color: rgba(29, 29, 29);
        border-radius: 6px;
      }
      .step p {
        margin: 0px;
      }

      .step a {
        color: #c3bfb5;
      }

      @media (max-width: 750px), (max-height: 750px) {
        .centered,
        .lefty,
        .righty,
        .fully {
          width: 95vw;
          margin: 0 auto;
        }
        .step div {
          line-height: 1.2em;
          padding: 10px 15px;
          font-size: 1em;
        }
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div id="story"></div>

    <script src="./ceded_IL_selectFields.js"></script>

    <script>
      const layerTypes = {
        fill: ["fill-opacity"],
        line: ["line-opacity"],
        circle: ["circle-opacity", "circle-stroke-opacity"],
        symbol: ["icon-opacity", "text-opacity"],
        raster: ["raster-opacity"],
      };

      const alignments = {
        left: "lefty",
        center: "centered",
        full: "fully",
      };

      const story = document.getElementById("story");
      const features = document.createElement("div");
      features.setAttribute("id", "features");

      ceded.features.forEach((record, idx) => {
        const container = document.createElement("div");
        const chapter = document.createElement("div");

        container.setAttribute("id", record.properties.id);
        container.classList.add("step");

        container.appendChild(chapter);
        container.classList.add("centered");
        container.classList.add("hidden");
        const story = document.createElement("p");

        story.innerHTML = record.properties.year;
        chapter.appendChild(story);

        features.appendChild(container);
      });

      story.appendChild(features);

      const scroller = scrollama();

      const selection = d3.select("#map");
      console.log(selection);
      const width = selection._groups[0][0].clientWidth;
      const height = selection._groups[0][0].clientHeight;

      const projection = d3
        .geoAlbers()
        .scale(8000)
        .rotate([89.2, 0])
        .center([0, 40])
        .translate([width / 2, height / 2]);

      const svg = d3
        .select("#map")
        .append("svg")
        .attr("width", width)
        .attr("height", height);

      svg
        .append("rect")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("fill", "#f5f5f5");

      const path = d3.geoPath().projection(projection);
      const ilGeo = svg.append("g");
      const cededGeo = svg.append("g");
      const rivers = svg.append("g");
      const lakes = svg.append("g");
      const dropCededFeature = svg.append("g");

      const cededColor = "#D4DBD0";
      const waterColor = "#dde6f1";

      //this is all for making the drop shadow used below
      const defs = dropCededFeature.append("defs");
      const filter = defs.append("filter").attr("id", "dropshadow");
      filter
        .append("feGaussianBlur")
        .attr("in", "SourceAlpha")
        .attr("stdDeviation", 1)
        .attr("result", "blur");
      filter
        .append("feOffset")
        .attr("in", "blur")
        .attr("dx", 0)
        .attr("dy", 0)
        .attr("result", "offsetBlur");
      const feMerge = filter.append("feMerge");
      feMerge.append("feMergeNode").attr("in", "offsetBlur");
      feMerge.append("feMergeNode").attr("in", "SourceGraphic");

      d3.json("IL.geojson").then(function (geojson) {
        ilGeo
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("fill", "#69b3a2")
          .attr("fill-opacity", 0)
          .attr("d", path)
          .style("stroke", "grey")
          .attr("stroke-width", "1");
      });

      d3.json("Lakes_simp.geojson").then(function (geojson) {
        lakes
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("fill", waterColor)
          .attr("fill-opacity", 1)
          .attr("d", path);
      });

      d3.json("Rivers_simp.geojson").then(function (geojson) {
        rivers
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("fill", "none")
          .attr("d", path)
          .style("stroke", waterColor)
          .attr("stroke-width", "1.5");
      });

      function makeMap(index, dropFeature) {
        const filtered = ceded.features.filter(function (feature) {
          return feature.properties.id > index;
        });

        cededGeo
          .selectAll("path")
          .data(filtered, (d) => d.properties.id)
          .join(
            function (enter) {
              return enter
                .append("path")
                .transition()
                .duration(1000)
                .attr("fill", cededColor)
                .attr("d", path)
                .attr("opacity", 1)
                .attr("fill-opacity", 1);
            },
            function (update) {
              return update;
            },
            function (exit) {
              return exit.remove();
            }
          );
        if (dropFeature) {
          console.log(dropFeature);
          dropCededFeature
            .selectAll("path")
            .data([dropFeature], (d) => d.properties.id)
            .join(
              function (enter) {
                return enter
                  .append("path")
                  .attr("d", path)
                  .attr("fill", cededColor)
                  .attr("opacity", 1)
                  .attr("fill-opacity", 1)
                  .attr("stroke-width", 0)

                  .transition()
                  .duration(400)
                  .style("stroke", "black")
                  // .attr("stroke-width", 1)
                  .attr("filter", "url(#dropshadow)")
                  .transition()
                  .duration(500)
                  .ease(d3.easeQuadIn)
                  .attr("transform", "translate(0," + height / 2 + ")")
                  .attr("opacity", 0)
                  .remove();
              },
              function (update) {
                return update;
              },
              function (exit) {
                return exit
                  .append("path")
                  .attr("d", path)
                  .attr("fill", cededColor)
                  .attr("opacity", 1)
                  .attr("fill-opacity", 1)
                  .attr("stroke-width", 0)
                  .transition()
                  .duration(500)
                  .style("stroke", "black")
                  .attr("stroke-width", 1)
                  .attr("filter", "url(#dropshadow)")
                  .transition()
                  .duration(500)
                  .ease(d3.easeQuadIn)
                  .attr("transform", "translate(0," + height + ")")
                  .attr("opacity", 0)
                  .remove();
              }
            );
        }
      }

      makeMap(0);

      scroller
        .setup({
          step: ".step",
          offset: 0.5,
          progress: false,
        })
        .onStepEnter((response) => {
          const id = parseInt(response.element.id);
          let dropFeature;
          if (response.direction === "down") {
            dropFeature = ceded.features[response.index];
          }
          response.direction === "up" && response.index === 0
            ? makeMap(0)
            : makeMap(id, dropFeature);
        })
        .onStepExit((response) => {});
    </script>
  </body>
</html>
