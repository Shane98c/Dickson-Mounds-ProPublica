<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Dickson Mounds</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <script src="lib/d3.v7.min.js"></script>
    <script src="lib/scrollama.min.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        top: 0;
        height: 100vh;
        width: 100vw;
        max-width: 100%;
        position: sticky;
        font-family: Graphik, sans-serif;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 0;
        min-width: 150px;
        max-width: 33%;
        text-align: center;
        right: 0;
        margin-left: auto;
        margin-right: auto;
      }

      #year {
        font-size: 2rem;
        color: rgb(81, 81, 81);
      }
      #tribes {
        font-size: 0.9rem;
        color: rgb(81, 81, 81);
      }

      .place-label {
        letter-spacing: 5px;
        color: grey;
        opacity: 0.5;
      }

      #features {
        pointer-events: none;
        padding-bottom: 10vh;
        transform: translate3d(0, 0, 0);
      }
      #features:last-of-type {
        padding-bottom: 100vh;
      }
      .hidden {
        visibility: hidden;
      }
      .centered {
        width: 90vw;
        max-width: 550px;
        margin: 0 auto;
      }
      .lefty {
        width: 33vw;
        max-width: 550px;
        margin-left: 5vw;
      }
      .step {
        z-index: 100;
        padding-bottom: 10vh;
        opacity: 0.95;
      }
      .step div {
        pointer-events: auto;
        padding: 15px 25px;
        line-height: 1.5rem;
        font-size: 1.1rem;
        font-family: Graphik, sans-serif;
        box-shadow: 2px 3px 10px rgb(0 0 0 / 50%);
        color: #c3bfb5;
        background-color: rgba(29, 29, 29);
        border-radius: 6px;
      }
      .step p {
        margin: 0px;
      }

      .step a {
        color: #c3bfb5;
      }

      @media (max-width: 750px), (max-height: 750px) {
        .centered,
        .lefty,
        .righty,
        .fully {
          width: 95vw;
          margin: 0 auto;
        }
        .step div {
          line-height: 1.2em;
          padding: 10px 15px;
          font-size: 1em;
        }
      }
    </style>
  </head>
  <body>
    <div id="map">
      <div id="info">
        <div id="year"></div>
        <div id="tribes"></div>
      </div>
    </div>

    <div id="story"></div>

    <script src="./ceded_IL_selectFields.js"></script>
    <script src="mapExtentFeature.js"></script>

    <script>
      //todo clip bounds to il
      //explainer then draw ceded bounds
      //maybe another layer to simulate change in opacity on shape drop
      //
      const layerTypes = {
        fill: ["fill-opacity"],
        line: ["line-opacity"],
        circle: ["circle-opacity", "circle-stroke-opacity"],
        symbol: ["icon-opacity", "text-opacity"],
        raster: ["raster-opacity"],
      };

      const alignments = {
        left: "lefty",
        center: "centered",
        full: "fully",
      };

      const years = new Set(
        ceded.features.map((feature) => {
          return feature.properties.year;
        })
      );

      years.add(new Date().getFullYear());

      const story = document.getElementById("story");
      const features = document.createElement("div");
      features.setAttribute("id", "features");

      years.forEach((year, idx) => {
        const container = document.createElement("div");
        const chapter = document.createElement("div");

        container.setAttribute("id", year);
        container.classList.add("step");

        container.appendChild(chapter);
        container.classList.add("centered");
        container.classList.add("hidden");
        const story = document.createElement("p");

        story.innerHTML = year;
        chapter.appendChild(story);

        features.appendChild(container);
      });

      story.appendChild(features);

      const scroller = scrollama();

      const selection = d3.select("#map");
      const width = selection._groups[0][0].clientWidth;
      const height = selection._groups[0][0].clientHeight;
    //   const width = 900;
    // const height = 600;

      const cededColor = "#D4DBD0";
      const dropFeatureColor = "#eaede8";
      const fadedColor = "#f5f5f5";
      const waterColor = "#dde6f1";
      const waterStroke = "#cedef2";
      const backgroundColor = "#D4DBD0";

      const projection = d3.geoMercator()
      .scale(1)
      .translate([0, 0]);

      const svg = d3
        .select("#map")
        .append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("preserveAspectRatio", "xMinYMin meet");

      svg
        .append("rect")
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("fill", backgroundColor);

      const path = d3.geoPath().projection(projection);
  
        const b = path.bounds(mapExtentFeature);

        // scale
        const s = 0.7 / Math.min((b[1][0] - b[0][0]) / width, (b[1][1] - b[0][1]) / height);  

        // transform
        const t = [(width - s * (b[1][0] + b[0][0])) / 2, (height - s * (b[1][1] + b[0][1])) / 2];

        // update projection
        projection
            .scale(s)
            .translate(t);

        // scale and postion
        const raster_width = (b[1][0] - b[0][0]) * s;
        const raster_height = (b[1][1] - b[0][1]) * s;

        const rtranslate_x = (width - raster_width) / 2;
        const rtranslate_y = (height - raster_height) / 2;

      const ilGeo = svg.append("g");
      const cededGeo = svg.append("g");
      const cededFader = svg.append("g");
      const rivers = svg.append("g");
      const lakes = svg.append("g");
      const ilStroke = svg.append("g");
      const dropCededFeature = svg.append("g");
      const labels = svg.append("g");
      svg
        .append("image")
        .attr("id", "Raster")
        .attr("xlink:href", "301_shade_x36_clip_extent.png")
        .attr("class", "raster")
        .attr("width", raster_width)
        .attr("height", raster_height)
        .attr("opacity", 0.2)

        .attr(
          "transform",
          "translate(" + rtranslate_x + ", " + rtranslate_y + ")"
        );

      //this is all for making the drop shadow used below
      const defs = dropCededFeature.append("defs");
      const filter = defs.append("filter").attr("id", "dropshadow");
      filter
        .append("feGaussianBlur")
        .attr("in", "SourceAlpha")
        .attr("stdDeviation", 1)
        .attr("result", "blur");
      filter
        .append("feOffset")
        .attr("in", "blur")
        .attr("dx", 0)
        .attr("dy", 0)
        .attr("result", "offsetBlur");
      const feMerge = filter.append("feMerge");
      feMerge.append("feMergeNode").attr("in", "offsetBlur");
      feMerge.append("feMergeNode").attr("in", "SourceGraphic");

      d3.json("IL.geojson").then(function (geojson) {
        ilGeo
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("fill", "#f5f5f5")
          .attr("fill-opacity", 1)
          .attr("d", path);

        ilStroke
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("fill-opacity", 0)
          .style("stroke", "grey")
          .attr("stroke-width", "2")
          .attr("stroke-opacity", "0.4");
      });

      d3.json("Lakes_simp.geojson").then(function (geojson) {
        lakes
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("fill", waterColor)
          .attr("fill-opacity", 1)
          .attr("d", path);
      });

      d3.json("Rivers_simp.geojson").then(function (geojson) {
        rivers
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("path")
          .attr("fill", "none")
          .attr("d", path)
          .style("stroke", waterColor)
          .attr("stroke-width", 1);
      });

      d3.json("labels.geojson").then(function (geojson) {
        labels
          .selectAll("path")
          .data(geojson.features)
          .enter()
          .append("text")
          .attr("class", "place-label")
          .text(function (d) {
            return d.properties.label;
          })
          .attr("transform", function (d) {
            return "translate(" + projection(d.geometry.coordinates) + ")";
          })
          .attr("text-anchor", "middle");
        // .attr('dx', -20)
        // .attr('dy', 15)
      });

      function makeMap(year, dropFeatures) {
        const filtered = ceded.features.filter(function (feature) {
          return feature.properties.year > year;
        });
        const faded = ceded.features.filter(function (feature) {
          if (year === 0) return false;
          return feature.properties.year <= year;
        });

        cededGeo
          .selectAll("path")
          .data(filtered, (d) => d.properties.id)
          .join(
            function (enter) {
              return (
                enter
                  .append("path")
                  .transition()
                  .duration(1000)
                  // .attr("stroke-width", 0.5)
                  // .style("stroke", "white")
                  .attr("fill", cededColor)
                  .attr("d", path)
                  .attr("opacity", 1)
                  .attr("fill-opacity", 1)
              );
            },
            function (update) {
              return update;
            },
            function (exit) {
              return exit.remove();
            }
          );
        // if (dropFeatures) {
        function dropTransition(moment) {
          return (
            moment
              .append("path")
              .attr("d", path)
              .attr("fill", cededColor)
              .attr("fill-opacity", 1)
              .attr("opacity", 1)
              .transition()
              .duration(600)
              .attr("fill", dropFeatureColor)
              .attr("opacity", 1)
              .attr("fill-opacity", 1)
              // .attr("stroke-width", 2)
              // .attr("stroke", 'white')
              .attr("filter", "url(#dropshadow)")
          );
        }
        dropCededFeature
          .selectAll("path")
          .data(dropFeatures, (d) => d.properties.id)
          .join(
            function (enter) {
              return dropTransition(enter);
            },
            function (update) {
              return update;
            },
            function (exit) {
              // return dropTransition(exit);
              return (
                exit
                  // .transition()
                  // .duration(500)
                  // .attr("opacity", 0)
                  .transition()
                  .duration(500)
                  .ease(d3.easeQuadIn)
                  // .attr("transform", "translate(0," + height + ")")
                  .attr("opacity", 0)
                  .remove()
                  .remove()
              );
            }
          );
        // }
        cededFader
          .selectAll("path")
          .data(faded, (d) => d.properties.id)

          .join(
            function (enter) {
              return enter
                .append("path")
                .attr("fill", cededColor)

                .transition()
                .duration(500)
                .attr("opacity", 0.4)

                .attr("stroke-width", 0)
                .attr("fill", fadedColor)
                .attr("d", path)
                .attr("fill-opacity", 1);
            },
            function (update) {
              return update;
            },
            function (exit) {
              return exit.remove();
            }
          );
      }

      makeMap(0, []);

      scroller
        .setup({
          step: ".step",
          offset: 0.5,
          progress: false,
        })
        .onStepEnter((response) => {
          const year = parseInt(response.element.id);
          let dropFeatures = [];
          if (response.direction === "down") {
            dropFeatures = ceded.features.filter((feature) => {
              return feature.properties.year === year;
            });
          }
          document.getElementById("year").innerHTML = year;
          response.direction === "up" && response.index === 0
            ? makeMap(0, [])
            : makeMap(year, dropFeatures);
        })
        .onStepExit((response) => {});
    </script>
  </body>
</html>
