<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Dickson Mounds</title>
    <meta
      name="viewport"
      content="initial-scale=1,maximum-scale=1,user-scalable=no"
    />
    <script src="lib/d3.v7.min.js"></script>
    <script src="lib/scrollama.min.js"></script>

    <style>
      body {
        margin: 0;
        padding: 0;
      }
      #map {
        top: 0;
        height: 100vh;
        width: 100vw;
        max-width: 100%;
        position: sticky;
        font-family: Graphik, sans-serif;
      }

      #info {
        position: absolute;
        top: 10px;
        left: 0;
        min-width: 150px;
        max-width: 33%;
        text-align: center;
        right: 0;
        margin-left: auto;
        margin-right: auto;
      }

      #year {
        font-size: 2rem;
        color: rgb(81, 81, 81);
      }
      #tribes {
        font-size: 0.9rem;
        color: rgb(81, 81, 81);
      }

      .explainer {
        padding-bottom: 80vh !important;
      }

      .place-label {
        letter-spacing: 15px;
        color: grey;
        opacity: 0.4;
      }

      #features {
        pointer-events: none;
        padding-bottom: 10vh;
        transform: translate3d(0, 0, 0);
      }
      #features:last-of-type {
        padding-bottom: 100vh;
      }
      .hidden {
        visibility: hidden;
      }
      .centered {
        width: 90vw;
        max-width: 550px;
        margin: 0 auto;
      }
      .lefty {
        width: 33vw;
        max-width: 550px;
        margin-left: 5vw;
      }
      .step {
        z-index: 100;
        padding-bottom: 50vh;
        opacity: 0.95;
      }
      .step div {
        pointer-events: auto;
        padding: 15px 25px;
        line-height: 1.5rem;
        font-size: 1.1rem;
        font-family: Graphik, sans-serif;
        box-shadow: 2px 3px 10px rgb(0 0 0 / 50%);
        color: #c3bfb5;
        background-color: rgba(29, 29, 29);
        border-radius: 6px;
      }
      .step p {
        margin: 0px;
      }

      .step a {
        color: #c3bfb5;
      }

      @media (max-width: 750px), (max-height: 750px) {
        .centered,
        .lefty,
        .righty,
        .fully {
          width: 95vw;
          margin: 0 auto;
        }
        .step div {
          line-height: 1.2em;
          padding: 10px 15px;
          font-size: 1em;
        }
      }
    </style>
  </head>
  <body>
    <div id="map">
      <div id="info">
        <div id="year"></div>
      </div>
    </div>

    <div id="story"></div>

    <script src="./ceded_IL_selectFields.js"></script>
    <script src="mapExtentFeature.js"></script>

    <script>
      //todo clip bounds to il
      //explainer then draw ceded bounds
      //maybe another layer to simulate change in opacity on shape drop
      //
      const layerTypes = {
        fill: ["fill-opacity"],
        line: ["line-opacity"],
        circle: ["circle-opacity", "circle-stroke-opacity"],
        symbol: ["icon-opacity", "text-opacity"],
        raster: ["raster-opacity"],
      };

      const alignments = {
        left: "lefty",
        center: "centered",
        full: "fully",
      };

      const years = new Set(
        ceded.features.map((feature) => {
          return feature.properties.year;
        })
      );

      years.add(new Date().getFullYear());

      let currentStep = 0;

      const story = document.getElementById("story");
      const features = document.createElement("div");
      features.setAttribute("id", "features");

      years.forEach((year, idx) => {
        const container = document.createElement("div");
        const chapter = document.createElement("div");

        container.setAttribute("id", year);
        container.classList.add("step");

        container.appendChild(chapter);
        container.classList.add("centered");
        container.classList.add("hidden");
        let story = document.createElement("p");

        story.innerHTML = year;

        if (year === 1803) {
          container.classList.remove("hidden");
          story.innerHTML = "Treaties took";
          container.classList.add("explainer");
        }
        chapter.appendChild(story);

        features.appendChild(container);
      });

      story.appendChild(features);

      const scroller = scrollama();

      const cededColor = "#D4DBD0",
        dropFeatureColor = "#eaede8",
        fadedColor = "#f5f5f5",
        waterColor = "#dde6f1",
        waterStroke = "#cedef2",
        backgroundColor = "#D4DBD0";

      const projection = d3.geoMercator().scale(1).translate([0, 0]);
      const path = d3.geoPath().projection(projection);

      function setupMap() {
        d3.select("svg").remove();
        const selection = d3.select("#map");
        const width = selection._groups[0][0].clientWidth;
        const height = selection._groups[0][0].clientHeight;

        const svg = d3
          .select("#map")
          .append("svg")
          .attr("width", "100%")
          .attr("height", "100%");

        svg
          .append("rect")
          .attr("width", "100%")
          .attr("height", "100%")
          .attr("opacity", 0.9)
          .attr("fill", backgroundColor);

        //get raster transformations
        //https://stackoverflow.com/questions/14492284/center-a-map-in-d3-given-a-geojson-object/14691788#14691788
        const b = path.bounds(mapExtentFeature);
        b.s = b[0][1];
        b.n = b[1][1];
        b.w = b[0][0];
        b.e = b[1][0];
        b.height = Math.abs(b.n - b.s);
        b.width = Math.abs(b.e - b.w);
        s = 0.9 / Math.max(b.width / width, b.height / height);
        const t = [
          (width - s * (b[1][0] + b[0][0])) / 2,
          (height - s * (b[1][1] + b[0][1])) / 2,
        ];
        projection.scale(s).translate(t);
        const raster_width = (b[1][0] - b[0][0]) * s;
        const raster_height = (b[1][1] - b[0][1]) * s;
        const rtranslate_x = (width - raster_width) / 2;
        const rtranslate_y = (height - raster_height) / 2;

        //setup layers
        const ilGeo = svg.append("g");
        const cededGeo = svg.append("g");
        const Raster = svg
          .append("image")
          .attr("id", "Raster")
          .attr("xlink:href", "301_z100_lt.png")
          .attr("class", "raster")
          .attr("width", raster_width)
          .attr("height", raster_height)
          .attr("opacity", 0.5)
          .attr(
            "transform",
            "translate(" + rtranslate_x + ", " + rtranslate_y + ")"
          );
        const cededFader = svg.append("g");
        const rivers = svg.append("g");
        const lakes = svg.append("g");
        const ilStroke = svg.append("g");
        const dropCededFeature = svg.append("g");
        const labels = svg.append("g");

        //this is all for making the drop shadow used below
        const defs = dropCededFeature.append("defs");
        const filter = defs.append("filter").attr("id", "dropshadow");
        filter
          .append("feGaussianBlur")
          .attr("in", "SourceAlpha")
          .attr("stdDeviation", 1)
          .attr("result", "blur");
        filter
          .append("feOffset")
          .attr("in", "blur")
          .attr("dx", 0)
          .attr("dy", 0)
          .attr("result", "offsetBlur");
        const feMerge = filter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "offsetBlur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        //add layers
        d3.json("IL.geojson").then(function (geojson) {
          ilGeo
            .selectAll("path")
            .data(geojson.features)
            .enter()
            .append("path")
            .attr("fill", "#f5f5f5")
            .attr("fill-opacity", 1)
            .attr("d", path);
          ilStroke
            .selectAll("path")
            .data(geojson.features)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("fill-opacity", 0)
            .style("stroke", "grey")
            .attr("stroke-width", "2")
            .attr("stroke-opacity", "0.4");
        });
        d3.json("Lakes_simp.geojson").then(function (geojson) {
          lakes
            .selectAll("path")
            .data(geojson.features)
            .enter()
            .append("path")
            .attr("fill", waterColor)
            .attr("fill-opacity", 1)
            .attr("d", path);
        });
        d3.json("Rivers_simp.geojson").then(function (geojson) {
          rivers
            .selectAll("path")
            .data(geojson.features)
            .enter()
            .append("path")
            .attr("fill", "none")
            .attr("d", path)
            .style("stroke", waterColor)
            .attr("stroke-width", 1);
        });
        d3.json("labels.geojson").then(function (geojson) {
          labels
            .selectAll("path")
            .data(geojson.features)
            .enter()
            .append("text")
            .attr("class", "place-label")
            .text(function (d) {
              return d.properties.label;
            })
            .attr("transform", function (d) {
              return "translate(" + projection(d.geometry.coordinates) + ")";
            })
            .attr("text-anchor", "middle");
          // .attr('dx', -20)
          // .attr('dy', 15)
        });
        return {
          cededGeo,
          dropCededFeature,
          cededFader,
        };
      }

      function updateMap(year, dropFeatures, layers) {
        //get features still waiting to be faded
        const stillHere = ceded.features.filter(function (feature) {
          return feature.properties.year > year;
        });

        //get features that should show up as faded on the map
        const faded = ceded.features.filter(function (feature) {
          if (year === 0) return false;
          return feature.properties.year <= year;
        });

        layers.cededGeo
          .selectAll("path")
          .data(stillHere, (d) => d.properties.id)
          .join(
            function (enter) {
              return (
                enter
                  .append("path")
                  .transition()
                  .duration(1000)
                  // .attr("stroke-width", 0.5)
                  // .style("stroke", "white")
                  .attr("fill", cededColor)
                  .attr("d", path)
                  .attr("opacity", 1)
                  .attr("fill-opacity", 1)
              );
            },
            function (update) {
              return update;
            },
            function (exit) {
              return exit.remove();
            }
          );
        function dropTransition(moment) {
          return moment
            .append("path")
            .attr("d", path)
            .attr("fill", cededColor)
            .attr("fill-opacity", 1)
            .attr("opacity", 1)
            .transition()
            .duration(600)
            .attr("fill", dropFeatureColor)
            .attr("opacity", 1)
            .attr("fill-opacity", 1)
            .attr("stroke-width", 2)
            .attr("stroke", "white")
            .attr("filter", "url(#dropshadow)");
        }
        layers.dropCededFeature
          .selectAll("path")
          .data(dropFeatures, (d) => d.properties.id)
          .join(
            function (enter) {
              return dropTransition(enter);
            },
            function (update) {
              return update;
            },
            function (exit) {
              return (
                exit
                  // .transition()
                  // .duration(500)
                  // .attr("opacity", 0)
                  .transition()
                  .duration(500)
                  // .ease(d3.easeQuadIn)
                  // .attr("transform", "translate(0," + height + ")")
                  .attr("opacity", 0)
                  .remove()
              );
            }
          );
        
        layers.cededFader
          .selectAll("path")
          .data(faded, (d) => d.properties.id)

          .join(
            function (enter) {
              return enter
                .append("path")
                .attr("fill", cededColor)
                .transition()
                .duration(500)
                .attr("opacity", 1)
                .attr("stroke-width", 0)
                .attr("fill", fadedColor)
                .attr("d", path)
                .attr("fill-opacity", 0.5);
            },
            function (update) {
              return update;
            },
            function (exit) {
              return exit.remove();
            }
          );
      }

      let layers = setupMap();
      updateMap(0, [], layers);

      scroller
        .setup({
          step: ".step",
          offset: 0.5,
          progress: false,
        })
        .onStepEnter((response) => {
          const year = parseInt(response.element.id);
          let dropFeatures = [];
          if (response.direction === "down") {
            dropFeatures = ceded.features.filter((feature) => {
              return feature.properties.year === year;
            });
          }
          document.getElementById("year").innerHTML = year;

          if (response.direction === "up" && response.index === 0) {
            currentStep = 0;
            updateMap(0, [], layers);
          } else {
            currentStep = year;
            updateMap(year, dropFeatures, layers);
          }
        });
      // .onStepExit((response) => {});

      function debounce(fn) {
        let timer;
        return function (event) {
          if (timer) clearTimeout(timer);
          timer = setTimeout(fn, 100, event);
        };
      }
      window.addEventListener(
        "resize",
        debounce(function () {
          layers = setupMap();
          updateMap(currentStep, [], layers);
        })
      );
    </script>
  </body>
</html>
